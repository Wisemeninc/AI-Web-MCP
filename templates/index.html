<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Chat Interface</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #0f0f0f;
            color: #e0e0e0;
            height: 100vh;
            display: grid;
            grid-template-columns: 1fr 350px;
            grid-template-rows: auto 1fr auto;
            grid-template-areas: 
                "header header"
                "chat sidebar"
                "input sidebar";
        }

        .header {
            grid-area: header;
            background: #1a1a1a;
            border-bottom: 1px solid #333;
            padding: 12px 20px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 15px;
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 15px;
            flex: 1;
        }

        .model-selector {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        select {
            background: #2a2a2a;
            color: #e0e0e0;
            border: 1px solid #444;
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 13px;
            cursor: pointer;
            outline: none;
        }

        select:hover {
            border-color: #666;
        }

        .mcp-status {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 12px;
            padding: 4px 10px;
            background: #2a2a2a;
            border-radius: 4px;
            cursor: pointer;
            user-select: none;
        }

        .mcp-status:hover {
            background: #333;
        }

        .mcp-details {
            position: absolute;
            top: 100%;
            right: 0;
            margin-top: 4px;
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 4px;
            padding: 8px;
            font-size: 11px;
            min-width: 200px;
            display: none;
            z-index: 1000;
        }

        .mcp-details.show {
            display: block;
        }

        .mcp-status-wrapper {
            position: relative;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #666;
        }

        .status-dot.connected {
            background: #4ade80;
            box-shadow: 0 0 8px #4ade8080;
        }

        .status-dot.disconnected {
            background: #ef4444;
        }

        .chat-container {
            grid-area: chat;
            overflow-y: auto;
            padding: 12px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .message {
            max-width: 80%;
            padding: 8px 12px;
            border-radius: 8px;
            line-height: 1.4;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .message.user {
            background: #2563eb;
            color: white;
            align-self: flex-end;
            margin-left: auto;
        }

        .message.assistant {
            background: #2a2a2a;
            color: #e0e0e0;
            align-self: flex-start;
            border: 1px solid #333;
        }

        .message.system {
            background: #7c3aed;
            color: white;
            align-self: center;
            font-size: 12px;
            max-width: 60%;
            padding: 6px 10px;
        }

        .message.tool-call {
            background: #f59e0b;
            color: #1a1a1a;
            align-self: center;
            font-size: 11px;
            max-width: 70%;
            font-family: 'Courier New', monospace;
            cursor: pointer;
            transition: opacity 0.2s;
            padding: 6px 10px;
        }

        .message.tool-call:hover {
            opacity: 0.8;
        }

        .message.tool-result {
            background: #10b981;
            color: #1a1a1a;
            align-self: center;
            font-size: 11px;
            max-width: 70%;
            font-family: 'Courier New', monospace;
            cursor: pointer;
            transition: opacity 0.2s;
            padding: 6px 10px;
        }

        .message.tool-result:hover {
            opacity: 0.8;
        }

        .tool-summary {
            font-weight: bold;
            margin-bottom: 2px;
        }

        .tool-details {
            margin-top: 2px;
            padding-top: 2px;
            border-top: 1px solid rgba(0,0,0,0.2);
            font-size: 10px;
        }

        .thinking-section {
            background: #2a2a4a;
            border: 1px solid #3a3a5a;
            border-radius: 4px;
            margin: 8px 0;
            padding: 8px;
            cursor: pointer;
            transition: opacity 0.2s;
        }

        .thinking-section:hover {
            opacity: 0.8;
        }

        .thinking-header {
            font-weight: bold;
            color: #a0a0ff;
            font-size: 11px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .thinking-content {
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid #3a3a5a;
            font-size: 12px;
            white-space: pre-wrap;
            font-family: 'Courier New', monospace;
        }

        .thinking-content.collapsed {
            display: none;
        }

        .toggle-icon {
            font-size: 10px;
        }

        .tool-details.collapsed {
            display: none;
        }

        .input-container {
            grid-area: input;
            background: #1a1a1a;
            border-top: 1px solid #333;
            padding: 15px 20px;
            display: flex;
            gap: 10px;
        }

        .sidebar {
            grid-area: sidebar;
            background: #1a1a1a;
            border-left: 1px solid #333;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .sidebar-section {
            display: flex;
            flex-direction: column;
            border-bottom: 1px solid #333;
            overflow: hidden;
        }

        .sidebar-section:last-child {
            border-bottom: none;
            flex: 1;
        }

        .activity-log {
            display: flex;
            flex-direction: column;
            gap: 4px;
            font-size: 11px;
            max-height: 300px;
            overflow-y: auto;
        }

        .activity-item {
            display: flex;
            align-items: flex-start;
            gap: 8px;
            padding: 6px 8px;
            background: #2a2a2a;
            border-radius: 4px;
            border-left: 3px solid #444;
        }

        .activity-item.connecting { border-left-color: #2196F3; }
        .activity-item.thinking { border-left-color: #FF9800; }
        .activity-item.streaming { border-left-color: #4CAF50; }
        .activity-item.tool { border-left-color: #9C27B0; }
        .activity-item.qa { border-left-color: #E91E63; }
        .activity-item.done { border-left-color: #4CAF50; }
        .activity-item.error { border-left-color: #f44336; }

        .activity-icon {
            flex-shrink: 0;
            width: 16px;
            text-align: center;
        }

        .activity-content {
            flex: 1;
            color: #bbb;
            line-height: 1.4;
        }

        .activity-time {
            flex-shrink: 0;
            color: #666;
            font-size: 10px;
        }

        .activity-item.active .activity-icon {
            animation: pulse 1s ease-in-out infinite;
        }

        .clear-log-btn {
            background: transparent;
            border: none;
            color: #666;
            font-size: 10px;
            cursor: pointer;
            padding: 2px 6px;
        }

        .clear-log-btn:hover {
            color: #999;
        }

        .sidebar-header {
            padding: 10px 15px;
            background: #222;
            border-bottom: 1px solid #333;
            font-size: 12px;
            font-weight: 600;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .sidebar-content {
            padding: 12px;
            overflow-y: auto;
            flex: 1;
        }

        .prompt-display {
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 4px;
            padding: 10px;
            font-size: 12px;
            line-height: 1.5;
            color: #bbb;
            white-space: pre-wrap;
            word-wrap: break-word;
            max-height: 200px;
            overflow-y: auto;
        }

        .prompt-editor {
            background: #2a2a2a;
            border: 1px solid #444;
            color: #e0e0e0;
            padding: 10px;
            border-radius: 4px;
            font-size: 12px;
            outline: none;
            resize: none;
            font-family: inherit;
            line-height: 1.5;
            width: 100%;
            min-height: 150px;
        }

        .prompt-editor:focus {
            border-color: #2563eb;
        }

        .prompt-actions {
            display: flex;
            gap: 8px;
            margin-top: 8px;
        }

        .prompt-button {
            background: #2563eb;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 11px;
            cursor: pointer;
            transition: background 0.2s;
            flex: 1;
        }

        .prompt-button:hover {
            background: #1d4ed8;
        }

        .prompt-button.secondary {
            background: #444;
        }

        .prompt-button.secondary:hover {
            background: #555;
        }

        .toggle-sidebar {
            display: none;
            background: #2563eb;
            color: white;
            border: none;
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 11px;
            cursor: pointer;
            margin-left: auto;
        }

        @media (max-width: 1024px) {
            body {
                grid-template-columns: 1fr;
                grid-template-areas: 
                    "header"
                    "chat"
                    "input";
            }

            .sidebar {
                display: none;
                position: fixed;
                right: 0;
                top: 0;
                bottom: 0;
                width: 350px;
                z-index: 1000;
                box-shadow: -2px 0 10px rgba(0,0,0,0.5);
            }

            .sidebar.show {
                display: flex;
            }

            .toggle-sidebar {
                display: block;
            }
        }

        #message-input {
            flex: 1;
            background: #2a2a2a;
            border: 1px solid #444;
            color: #e0e0e0;
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 14px;
            outline: none;
            resize: none;
            font-family: inherit;
            max-height: 150px;
        }

        #message-input:focus {
            border-color: #2563eb;
        }

        #send-button {
            background: #2563eb;
            color: white;
            border: none;
            padding: 10px 24px;
            border-radius: 8px;
            font-size: 14px;
            cursor: pointer;
            transition: background 0.2s;
            white-space: nowrap;
        }

        #send-button:hover:not(:disabled) {
            background: #1d4ed8;
        }

        #send-button:disabled {
            background: #444;
            cursor: not-allowed;
            opacity: 0.6;
        }

        .typing-indicator {
            display: none;
            align-self: flex-start;
            background: #2a2a2a;
            padding: 12px 16px;
            border-radius: 12px;
            border: 1px solid #333;
        }

        .typing-indicator.active {
            display: block;
        }

        .typing-dots {
            display: flex;
            gap: 4px;
        }

        .typing-dots span {
            width: 8px;
            height: 8px;
            background: #666;
            border-radius: 50%;
            animation: typing 1.4s infinite;
        }

        .typing-dots span:nth-child(2) {
            animation-delay: 0.2s;
        }

        .typing-dots span:nth-child(3) {
            animation-delay: 0.4s;
        }

        @keyframes typing {
            0%, 60%, 100% {
                transform: translateY(0);
                opacity: 0.7;
            }
            30% {
                transform: translateY(-10px);
                opacity: 1;
            }
        }

        @keyframes pulse {
            0%, 100% {
                opacity: 1;
            }
            50% {
                opacity: 0.6;
            }
        }

        .stats-bar {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            border-top: 1px solid #333;
            padding: 8px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 11px;
            color: #888;
            min-height: 32px;
        }

        .stats-bar.active {
            color: #aaa;
        }

        .stats-left, .stats-right {
            display: flex;
            gap: 20px;
            align-items: center;
        }

        .stat-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .stat-item .stat-icon {
            font-size: 12px;
        }

        .stat-item .stat-label {
            color: #666;
        }

        .stat-item .stat-value {
            color: #4CAF50;
            font-weight: 500;
            font-family: 'Consolas', 'Monaco', monospace;
        }

        .stat-item.streaming .stat-value {
            color: #ff9800;
            animation: pulse 1s ease-in-out infinite;
        }

        .stat-item.waiting .stat-value {
            color: #2196F3;
            animation: pulse 2s ease-in-out infinite;
        }

        .stats-status {
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 10px;
            font-weight: 500;
        }

        .stats-status.idle {
            background: #333;
            color: #666;
        }

        .stats-status.thinking {
            background: #1565C0;
            color: #fff;
            animation: pulse 2s ease-in-out infinite;
        }

        .stats-status.streaming {
            background: #E65100;
            color: #fff;
        }

        .stats-status.done {
            background: #2E7D32;
            color: #fff;
        }

        .empty-state {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #666;
            font-size: 14px;
            text-align: center;
        }

        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #1a1a1a;
        }

        ::-webkit-scrollbar-thumb {
            background: #444;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #555;
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="header-left">
            <div class="model-selector">
                <select id="provider-select">
                    <option value="">Select Provider</option>
                </select>
                <select id="model-select" disabled>
                    <option value="">Select Model</option>
                </select>
            </div>
        </div>
        <button class="toggle-sidebar" id="toggle-sidebar">Prompts ‚ò∞</button>
        <div class="mcp-status-wrapper">
            <div class="mcp-status" id="mcp-status-container">
                <span class="status-dot" id="mcp-dot"></span>
                <span id="mcp-text">MCP: Checking...</span>
            </div>
            <div class="mcp-details" id="mcp-details"></div>
        </div>
    </div>

    <div class="chat-container" id="chat-container">
        <div class="empty-state">
            Select a provider and model to start chatting
        </div>
    </div>

    <div class="typing-indicator" id="typing-indicator">
        <div class="typing-dots">
            <span></span>
            <span></span>
            <span></span>
        </div>
    </div>

    <div class="input-container">
        <textarea id="message-input" placeholder="Type your message..." rows="1"></textarea>
        <button id="send-button" disabled>Send</button>
    </div>

    <div class="stats-bar" id="stats-bar">
        <div class="stats-left">
            <div class="stat-item" id="stat-status-container">
                <span class="stats-status idle" id="stats-status">Idle</span>
            </div>
            <div class="stat-item" id="stat-time-container" style="display: none;">
                <span class="stat-icon">‚è±Ô∏è</span>
                <span class="stat-label">Time:</span>
                <span class="stat-value" id="stat-time">0.0s</span>
            </div>
            <div class="stat-item" id="stat-ttft-container" style="display: none;">
                <span class="stat-icon">üöÄ</span>
                <span class="stat-label">TTFT:</span>
                <span class="stat-value" id="stat-ttft">-</span>
            </div>
        </div>
        <div class="stats-right">
            <div class="stat-item" id="stat-tokens-container" style="display: none;">
                <span class="stat-icon">üìù</span>
                <span class="stat-label">Tokens:</span>
                <span class="stat-value" id="stat-tokens">0</span>
            </div>
            <div class="stat-item" id="stat-speed-container" style="display: none;">
                <span class="stat-icon">üî•</span>
                <span class="stat-label">Speed:</span>
                <span class="stat-value" id="stat-speed">0</span>
                <span class="stat-label">tok/s</span>
            </div>
        </div>
    </div>

    <div class="sidebar" id="sidebar">
        <div class="sidebar-section">
            <div class="sidebar-header">
                <span>System Prompt</span>
            </div>
            <div class="sidebar-content">
                <div class="prompt-display" id="system-prompt-display">Loading...</div>
            </div>
        </div>
        
        <div class="sidebar-section">
            <div class="sidebar-header">
                <span>User Prompt</span>
            </div>
            <div class="sidebar-content">
                <textarea class="prompt-editor" id="user-prompt-editor" placeholder="Enter custom instructions for the AI..."></textarea>
                <div class="prompt-actions">
                    <button class="prompt-button" id="apply-user-prompt">Apply</button>
                    <button class="prompt-button secondary" id="clear-user-prompt">Clear</button>
                </div>
            </div>
        </div>
        
        <div class="sidebar-section">
            <div class="sidebar-header">
                <span>Activity Log</span>
                <button class="clear-log-btn" id="clear-activity-log">Clear</button>
            </div>
            <div class="sidebar-content">
                <div class="activity-log" id="activity-log">
                    <div class="activity-item" style="color: #666; text-align: center;">
                        <span class="activity-content">No activity yet</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let providers = {};
        let currentProvider = '';
        let currentModel = '';
        let messages = [];
        let isStreaming = false;
        let messageHistory = [];
        let historyIndex = -1;
        let systemPrompt = 'You are a helpful AI assistant.';
        let userPrompt = '';

        // Message history management
        const MAX_MESSAGE_HISTORY = 50;  // Keep last 50 messages

        function pruneMessageHistory() {
            if (messages.length > MAX_MESSAGE_HISTORY) {
                // Keep system message + last N messages
                const systemMsg = messages.find(m => m.role === 'system');
                const recentMessages = messages.slice(-MAX_MESSAGE_HISTORY);
                messages = systemMsg ? [systemMsg, ...recentMessages.filter(m => m.role !== 'system')] : recentMessages;
                console.log(`[Memory] Pruned message history to ${messages.length} messages`);
            }
        }

        // Statistics tracking
        let statsStartTime = null;
        let statsTimer = null;
        let currentStats = { tokens: 0, ttft: null };
        let lastSpeedUpdate = 0;  // Track last speed calculation

        // Elements
        const providerSelect = document.getElementById('provider-select');
        const modelSelect = document.getElementById('model-select');
        const chatContainer = document.getElementById('chat-container');
        const messageInput = document.getElementById('message-input');
        const sendButton = document.getElementById('send-button');
        const typingIndicator = document.getElementById('typing-indicator');
        const mcpDot = document.getElementById('mcp-dot');
        const mcpText = document.getElementById('mcp-text');
        const systemPromptDisplay = document.getElementById('system-prompt-display');
        const userPromptEditor = document.getElementById('user-prompt-editor');
        const applyUserPromptBtn = document.getElementById('apply-user-prompt');
        const clearUserPromptBtn = document.getElementById('clear-user-prompt');
        const toggleSidebarBtn = document.getElementById('toggle-sidebar');
        const sidebar = document.getElementById('sidebar');
        const activityLog = document.getElementById('activity-log');
        const clearActivityLogBtn = document.getElementById('clear-activity-log');

        // Statistics elements
        const statsBar = document.getElementById('stats-bar');
        const statsStatus = document.getElementById('stats-status');
        const statTimeContainer = document.getElementById('stat-time-container');
        const statTime = document.getElementById('stat-time');
        const statTtftContainer = document.getElementById('stat-ttft-container');
        const statTtft = document.getElementById('stat-ttft');
        const statTokensContainer = document.getElementById('stat-tokens-container');
        const statTokens = document.getElementById('stat-tokens');
        const statSpeedContainer = document.getElementById('stat-speed-container');
        const statSpeed = document.getElementById('stat-speed');

        // Statistics functions
        function resetStats() {
            statsStartTime = null;
            currentStats = { tokens: 0, ttft: null };
            if (statsTimer) {
                clearInterval(statsTimer);
                statsTimer = null;
            }
        }

        // Activity Log functions
        let activityStartTime = null;
        
        function clearActivityLog() {
            activityLog.innerHTML = '<div class="activity-item" style="color: #666; text-align: center;"><span class="activity-content">No activity yet</span></div>';
        }
        
        function addActivityItem(type, message, icon = null) {
            // Remove "no activity" placeholder
            const placeholder = activityLog.querySelector('.activity-item[style]');
            if (placeholder) placeholder.remove();
            
            // Remove active class from previous items
            activityLog.querySelectorAll('.activity-item.active').forEach(item => {
                item.classList.remove('active');
            });
            
            const icons = {
                'connecting': 'üîå',
                'thinking': 'üß†',
                'streaming': 'üì°',
                'tool': 'üîß',
                'tool_result': '‚úÖ',
                'qa': 'üîç',
                'done': '‚úì',
                'error': '‚ùå',
                'info': '‚ÑπÔ∏è'
            };
            
            const elapsed = activityStartTime ? ((Date.now() - activityStartTime) / 1000).toFixed(1) + 's' : '';
            
            const item = document.createElement('div');
            item.className = `activity-item ${type}`;
            if (type !== 'done' && type !== 'error') {
                item.classList.add('active');
            }
            
            item.innerHTML = `
                <span class="activity-icon">${icon || icons[type] || '‚Ä¢'}</span>
                <span class="activity-content">${message}</span>
                <span class="activity-time">${elapsed}</span>
            `;
            
            activityLog.appendChild(item);
            activityLog.scrollTop = activityLog.scrollHeight;
        }
        
        function startActivityLog(model) {
            clearActivityLog();
            activityStartTime = Date.now();
            addActivityItem('info', `Starting query with ${model}`, 'üöÄ');
        }
        
        // Clear activity log button
        clearActivityLogBtn.addEventListener('click', clearActivityLog);

        function startStats() {
            resetStats();
            statsStartTime = Date.now();
            currentStats.tokens = 0;
            
            // Show stats elements
            statsBar.classList.add('active');
            statTimeContainer.style.display = 'flex';
            statTtftContainer.style.display = 'flex';
            statTokensContainer.style.display = 'flex';
            statSpeedContainer.style.display = 'flex';
            
            // Update status
            statsStatus.className = 'stats-status thinking';
            statsStatus.textContent = 'Thinking...';
            statTtft.textContent = '-';
            statTokens.textContent = '0';
            statSpeed.textContent = '0';
            
            // Add waiting class for animation
            statTimeContainer.classList.add('waiting');
            statTimeContainer.classList.remove('streaming');
            
            // Start timer (500ms interval instead of 100ms - reduces CPU usage by 80%)
            statsTimer = setInterval(updateStatsTimer, 500);
        }

        function updateStatsTimer() {
            if (statsStartTime) {
                const now = Date.now();
                const elapsed = (now - statsStartTime) / 1000;
                statTime.textContent = elapsed.toFixed(1) + 's';

                // Update speed only every 1 second (not every tick)
                if (now - lastSpeedUpdate > 1000 && currentStats.ttft !== null && currentStats.tokens > 0) {
                    const genTime = elapsed - currentStats.ttft;
                    if (genTime > 0) {
                        const speed = currentStats.tokens / genTime;
                        statSpeed.textContent = speed.toFixed(1);
                        lastSpeedUpdate = now;
                    }
                }
            }
        }

        function updateStatsTTFT(ttft) {
            currentStats.ttft = ttft;
            statTtft.textContent = ttft.toFixed(2) + 's';
            statsStatus.className = 'stats-status streaming';
            statsStatus.textContent = 'Streaming';
            
            // Switch to streaming animation
            statTimeContainer.classList.remove('waiting');
            statTimeContainer.classList.add('streaming');
        }

        function updateStatsTokens(count) {
            currentStats.tokens = count;
            statTokens.textContent = count;
        }

        function incrementStatsTokens() {
            currentStats.tokens++;
            statTokens.textContent = currentStats.tokens;
        }

        function finishStats(finalStats) {
            if (statsTimer) {
                clearInterval(statsTimer);
                statsTimer = null;
            }
            
            statsStatus.className = 'stats-status done';
            statsStatus.textContent = 'Done';
            
            // Remove animations
            statTimeContainer.classList.remove('waiting', 'streaming');
            
            if (finalStats) {
                statTime.textContent = finalStats.total_time.toFixed(2) + 's';
                statTtft.textContent = finalStats.ttft.toFixed(2) + 's';
                statTokens.textContent = finalStats.tokens;
                statSpeed.textContent = finalStats.tokens_per_sec.toFixed(1);
            }
        }

        // Load providers
        async function loadProviders() {
            try {
                const response = await fetch('/api/providers');
                providers = await response.json();
                
                providerSelect.innerHTML = '<option value="">Select Provider</option>';
                Object.keys(providers).forEach(key => {
                    const option = document.createElement('option');
                    option.value = key;
                    option.textContent = providers[key].name;
                    providerSelect.appendChild(option);
                });
                return providers;
            } catch (error) {
                console.error('Failed to load providers:', error);
                return {};
            }
        }

        // Check MCP status
        async function checkMCPStatus() {
            try {
                const response = await fetch('/api/mcp/status');
                const data = await response.json();
                
                if (data.connected) {
                    mcpDot.classList.add('connected');
                    mcpDot.classList.remove('disconnected');
                    mcpText.textContent = 'MCP: ' + data.message;
                    
                    // Update details panel
                    const detailsHtml = data.servers.map(s => 
                        `<div style="padding: 4px 0;">${s.connected ? '‚úì' : '‚úó'} ${s.name}: ${s.message}</div>`
                    ).join('');
                    mcpDetails.innerHTML = detailsHtml;
                } else {
                    mcpDot.classList.remove('connected');
                    mcpDot.classList.add('disconnected');
                    mcpText.textContent = 'MCP: ' + data.message;
                    mcpDetails.innerHTML = '<div style="padding: 4px 0;">No servers connected</div>';
                }
            } catch (error) {
                mcpDot.classList.remove('connected');
                mcpDot.classList.add('disconnected');
                mcpText.textContent = 'MCP: Error';
                mcpDetails.innerHTML = '<div style="padding: 4px 0;">Connection error</div>';
            }
        }

        // Toggle MCP details
        const mcpStatusContainer = document.getElementById('mcp-status-container');
        const mcpDetails = document.getElementById('mcp-details');
        
        mcpStatusContainer.addEventListener('click', () => {
            mcpDetails.classList.toggle('show');
        });

        // Close details when clicking outside
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.mcp-status-wrapper')) {
                mcpDetails.classList.remove('show');
            }
        });

        // Provider change handler
        providerSelect.addEventListener('change', (e) => {
            currentProvider = e.target.value;
            modelSelect.innerHTML = '<option value="">Select Model</option>';
            
            if (currentProvider && providers[currentProvider]) {
                const models = providers[currentProvider].models;
                models.forEach(model => {
                    const option = document.createElement('option');
                    option.value = model;
                    option.textContent = model;
                    modelSelect.appendChild(option);
                });
                modelSelect.disabled = false;
            } else {
                modelSelect.disabled = true;
                currentModel = '';
                sendButton.disabled = true;
            }
        });

        // Model change handler
        modelSelect.addEventListener('change', (e) => {
            currentModel = e.target.value;
            sendButton.disabled = !currentModel;
        });

        // Render message with collapsible thinking sections
        function renderMessageWithThinking(messageDiv, content) {
            let remainingContent = content;

            // Process scratchpad/thinking sections - make them collapsible
            remainingContent = remainingContent.replace(/<(scratchpad|thinking)>([\s\S]*?)<\/(scratchpad|thinking)>/gi,
                (match, tag, thinkingContent) => {
                    const id = 'thinking-' + Math.random().toString(36).substr(2, 9);
                    return `<div class="thinking-section" onclick="document.getElementById('${id}').classList.toggle('collapsed')">
                        <div class="thinking-header"><span class="toggle-icon">‚ñº</span> ${tag.charAt(0).toUpperCase() + tag.slice(1)}</div>
                        <div class="thinking-content collapsed" id="${id}">${escapeHtml(thinkingContent.trim())}</div>
                    </div>`;
                }
            );

            // Remove answer tags but keep the content visible
            remainingContent = remainingContent.replace(/<\/?answer>/gi, '');

            // Escape HTML for safety, but preserve the collapsible divs we already created
            // Split by thinking-section divs, escape the text parts, then recombine
            const parts = remainingContent.split(/(<div class="thinking-section"[\s\S]*?<\/div><\/div>)/);
            remainingContent = parts.map((part, index) => {
                // Even indices are text content, odd indices are our generated divs
                if (index % 2 === 0) {
                    // This is text content - escape it and convert newlines
                    return escapeHtml(part).replace(/\n/g, '<br>');
                } else {
                    // This is a thinking-section div - keep as is
                    return part;
                }
            }).join('');

            console.log('[Render] Content length:', remainingContent.length, 'Has answer content:', !content.includes('<answer>') || content.split('<\/answer>')[1]?.length > 0);
            messageDiv.innerHTML = remainingContent;
        }
        
        // Escape HTML to prevent XSS
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Add message to chat
        function addMessage(role, content) {
            const emptyState = chatContainer.querySelector('.empty-state');
            if (emptyState) {
                emptyState.remove();
            }

            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${role}`;
            messageDiv.textContent = content;
            chatContainer.appendChild(messageDiv);
            
            // Smooth scroll to bottom
            chatContainer.scrollTo({
                top: chatContainer.scrollHeight,
                behavior: 'smooth'
            });
            
            return messageDiv;
        }

        // Load system prompt from backend
        async function loadSystemPrompt() {
            try {
                const response = await fetch('/api/system-prompt');
                const data = await response.json();
                systemPrompt = data.system_prompt || 'You are a helpful AI assistant.';
                // Replace \n with actual newlines for display
                systemPromptDisplay.textContent = systemPrompt.replace(/\\n/g, '\n');
            } catch (error) {
                console.error('Failed to load system prompt:', error);
                systemPromptDisplay.textContent = 'Error loading system prompt';
            }
        }

        // Apply user prompt
        applyUserPromptBtn.addEventListener('click', () => {
            userPrompt = userPromptEditor.value.trim();
            if (userPrompt) {
                addMessage('system', '‚úì User prompt applied: ' + userPrompt.substring(0, 100) + (userPrompt.length > 100 ? '...' : ''));
            }
        });

        // Clear user prompt
        clearUserPromptBtn.addEventListener('click', () => {
            userPrompt = '';
            userPromptEditor.value = '';
            addMessage('system', '‚úì User prompt cleared');
        });

        // Toggle sidebar on mobile
        toggleSidebarBtn.addEventListener('click', () => {
            sidebar.classList.toggle('show');
        });

        // Close sidebar when clicking outside on mobile
        document.addEventListener('click', (e) => {
            if (window.innerWidth <= 1024 && 
                !e.target.closest('.sidebar') && 
                !e.target.closest('.toggle-sidebar')) {
                sidebar.classList.remove('show');
            }
        });

        // Send message
        async function sendMessage() {
            const content = messageInput.value.trim();
            if (!content || !currentProvider || !currentModel || isStreaming) return;

            isStreaming = true;
            sendButton.disabled = true;
            
            // Start statistics tracking
            startStats();
            
            // Start activity log
            startActivityLog(currentModel);
            
            // Add to history
            messageHistory.push(content);
            historyIndex = messageHistory.length;
            
            messageInput.value = '';
            
            // Combine user prompt with message if set
            let finalContent = content;
            if (userPrompt) {
                finalContent = `${userPrompt}\n\n${content}`;
            }
            
            // Add user message (display original, send combined)
            messages.push({ role: 'user', content: finalContent });
            addMessage('user', content);
            
            // Show typing indicator
            typingIndicator.classList.add('active');
            chatContainer.appendChild(typingIndicator);
            
            try {
                const response = await fetch('/api/chat', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        messages: messages,
                        provider: currentProvider,
                        model: currentModel
                    })
                });

                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let assistantMessage = '';
                let messageDiv = null;
                let streamDone = false;
                let buffer = '';  // Buffer for incomplete lines

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) {
                        console.log('Stream ended. Final message length:', assistantMessage.length);
                        break;
                    }

                    const chunk = decoder.decode(value, { stream: true });
                    buffer += chunk;
                    const lines = buffer.split('\n');

                    // Keep the last line in buffer if it doesn't end with \n
                    buffer = lines.pop() || '';

                    for (const line of lines) {
                        if (line.startsWith('data: ')) {
                            try {
                                const data = JSON.parse(line.slice(6));
                                
                                // Handle status messages (for slow/thinking models)
                                if (data.status) {
                                    console.log('Model status:', data.status, data.message);
                                    // Update typing indicator with status message
                                    const statusText = typingIndicator.querySelector('.status-text') || (() => {
                                        const span = document.createElement('span');
                                        span.className = 'status-text';
                                        span.style.marginLeft = '8px';
                                        span.style.fontSize = '0.85em';
                                        span.style.opacity = '0.8';
                                        typingIndicator.appendChild(span);
                                        return span;
                                    })();
                                    statusText.textContent = data.message || '';
                                    
                                    // Update stats bar and activity log based on status
                                    if (data.status === 'connecting') {
                                        addActivityItem('connecting', data.message || 'Connecting to model...');
                                    } else if (data.status === 'connected') {
                                        statsStatus.className = 'stats-status thinking';
                                        statsStatus.textContent = 'Connected';
                                        addActivityItem('connecting', data.message || 'Connected');
                                    } else if (data.status === 'thinking') {
                                        typingIndicator.style.animation = 'pulse 2s ease-in-out infinite';
                                        statsStatus.className = 'stats-status thinking';
                                        statsStatus.textContent = 'Thinking...';
                                        addActivityItem('thinking', data.message || 'Model is thinking...');
                                    } else if (data.status === 'streaming') {
                                        typingIndicator.style.animation = '';
                                        // Extract TTFT from message if available
                                        const ttftMatch = data.message && data.message.match(/([\d.]+)s/);
                                        if (ttftMatch && currentStats.ttft === null) {
                                            updateStatsTTFT(parseFloat(ttftMatch[1]));
                                            addActivityItem('streaming', `First token received in ${ttftMatch[1]}s`);
                                        }
                                    } else if (data.status === 'qa_retry') {
                                        // QA Agent is requesting more data
                                        statsStatus.className = 'stats-status thinking';
                                        statsStatus.textContent = 'QA Retry';
                                        typingIndicator.style.animation = 'pulse 1s ease-in-out infinite';
                                        console.log('%cüîç QA Agent triggered follow-up request', 'color: #FF9800; font-weight: bold');
                                        addActivityItem('qa', data.message || 'QA Agent requesting clarification...');
                                    }
                                }
                                
                                if (data.content) {
                                    if (!messageDiv) {
                                        typingIndicator.classList.remove('active');
                                        messageDiv = addMessage('assistant', '');
                                        // First content received - update TTFT if not already set
                                        if (currentStats.ttft === null && statsStartTime) {
                                            updateStatsTTFT((Date.now() - statsStartTime) / 1000);
                                            addActivityItem('streaming', 'Receiving response...');
                                        }
                                    }
                                    assistantMessage += data.content;
                                    
                                    // Update token count in stats
                                    incrementStatsTokens();
                                    
                                    // Process and render message with collapsible thinking sections
                                    renderMessageWithThinking(messageDiv, assistantMessage);
                                    
                                    // Keep scrolling to bottom during streaming
                                    chatContainer.scrollTop = chatContainer.scrollHeight;
                                }
                                
                                if (data.tool_call) {
                                    typingIndicator.classList.remove('active');
                                    const argsStr = JSON.stringify(data.arguments, null, 2);
                                    const toolMsg = document.createElement('div');
                                    toolMsg.className = 'message tool-call';
                                    toolMsg.innerHTML = `<div class="tool-summary">üîß ${data.tool_call}</div><div class="tool-details collapsed">${argsStr}</div>`;
                                    toolMsg.onclick = function() {
                                        this.querySelector('.tool-details').classList.toggle('collapsed');
                                    };
                                    chatContainer.appendChild(toolMsg);
                                    chatContainer.scrollTop = chatContainer.scrollHeight;
                                    addActivityItem('tool', `Calling tool: ${data.tool_call}`);
                                }
                                
                                if (data.tool_result) {
                                    const resultStr = JSON.stringify(data.result, null, 2);
                                    const resultMsg = document.createElement('div');
                                    resultMsg.className = 'message tool-result';
                                    resultMsg.innerHTML = `<div class="tool-summary">‚úì ${data.tool_result}</div><div class="tool-details collapsed">${resultStr}</div>`;
                                    resultMsg.onclick = function() {
                                        this.querySelector('.tool-details').classList.toggle('collapsed');
                                    };
                                    chatContainer.appendChild(resultMsg);
                                    chatContainer.scrollTop = chatContainer.scrollHeight;
                                    addActivityItem('tool_result', `Tool result: ${data.tool_result}`);
                                }
                                
                                if (data.done) {
                                    streamDone = true;
                                    // Log statistics if available and update stats bar
                                    if (data.stats) {
                                        const s = data.stats;
                                        console.log('%c‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'color: #4CAF50');
                                        console.log('%cüìä Query Statistics', 'color: #4CAF50; font-weight: bold; font-size: 14px');
                                        console.log('%c‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'color: #4CAF50');
                                        console.log(`‚è±Ô∏è  Total time:         ${s.total_time}s`);
                                        console.log(`üöÄ Time to first token: ${s.ttft}s`);
                                        console.log(`‚ö° Generation time:     ${s.generation_time}s`);
                                        console.log(`üìù Total tokens:        ${s.tokens}`);
                                        console.log(`üìÑ Total characters:    ${s.chars}`);
                                        console.log(`üî• Speed:               ${s.tokens_per_sec} tokens/s`);
                                        console.log('%c‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê', 'color: #4CAF50');
                                        
                                        // Update stats bar with final statistics
                                        finishStats(s);
                                        addActivityItem('done', `Complete: ${s.tokens} tokens in ${s.total_time}s (${s.tokens_per_sec} tok/s)`);
                                    } else {
                                        finishStats(null);
                                        addActivityItem('done', 'Response complete');
                                    }
                                }
                                
                                if (data.error) {
                                    typingIndicator.classList.remove('active');
                                    addMessage('system', 'Error: ' + data.error);
                                    finishStats(null);
                                    statsStatus.className = 'stats-status idle';
                                    statsStatus.textContent = 'Error';
                                    addActivityItem('error', `Error: ${data.error}`);
                                }
                            } catch (e) {
                                console.error('Parse error:', e, 'Line:', line);
                            }
                        }
                    }
                }
                
                // Always save the assistant message after stream ends
                if (assistantMessage) {
                    messages.push({ role: 'assistant', content: assistantMessage });
                    pruneMessageHistory();  // Prevent unbounded memory growth
                    console.log('Saved assistant message. Total length:', assistantMessage.length);
                }
            } catch (error) {
                console.error('Error:', error);
                typingIndicator.classList.remove('active');
                addMessage('system', 'Error: ' + error.message);
            } finally {
                isStreaming = false;
                sendButton.disabled = !currentModel;
                typingIndicator.classList.remove('active');
            }
        }

        // Send button click
        sendButton.addEventListener('click', sendMessage);

        // Enter key to send (Shift+Enter for new line), arrow keys for history
        messageInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendMessage();
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                if (messageHistory.length > 0 && historyIndex > 0) {
                    historyIndex--;
                    messageInput.value = messageHistory[historyIndex];
                    // Move cursor to end
                    messageInput.setSelectionRange(messageInput.value.length, messageInput.value.length);
                    // Trigger resize
                    messageInput.dispatchEvent(new Event('input'));
                }
            } else if (e.key === 'ArrowDown') {
                e.preventDefault();
                if (historyIndex < messageHistory.length - 1) {
                    historyIndex++;
                    messageInput.value = messageHistory[historyIndex];
                    // Move cursor to end
                    messageInput.setSelectionRange(messageInput.value.length, messageInput.value.length);
                    // Trigger resize
                    messageInput.dispatchEvent(new Event('input'));
                } else if (historyIndex === messageHistory.length - 1) {
                    historyIndex = messageHistory.length;
                    messageInput.value = '';
                    messageInput.dispatchEvent(new Event('input'));
                }
            }
        });

        // Auto-resize textarea
        messageInput.addEventListener('input', () => {
            messageInput.style.height = 'auto';
            messageInput.style.height = messageInput.scrollHeight + 'px';
        });

        // Initialize
        loadProviders().then(() => {
            // Set default provider and model
            const defaultProvider = 'ollama';
            const defaultModel = 'phi3:14b';  // Use smaller model that doesn't crash
            
            if (providers[defaultProvider]) {
                providerSelect.value = defaultProvider;
                currentProvider = defaultProvider;
                
                // Populate models
                modelSelect.innerHTML = '<option value="">Select Model</option>';
                const models = providers[defaultProvider].models;
                models.forEach(model => {
                    const option = document.createElement('option');
                    option.value = model;
                    option.textContent = model;
                    if (model === defaultModel) {
                        option.selected = true;
                    }
                    modelSelect.appendChild(option);
                });
                
                modelSelect.disabled = false;
                
                // Set default model
                if (models.includes(defaultModel)) {
                    currentModel = defaultModel;
                    modelSelect.value = defaultModel;
                    sendButton.disabled = false;
                }
            }
            
            // Focus the input field after initialization
            messageInput.focus();
        });
        
        // Load system prompt
        loadSystemPrompt();
        
        // Check MCP status
        checkMCPStatus();
        setInterval(checkMCPStatus, 10000); // Check MCP status every 10 seconds
    </script>
</body>
</html>
