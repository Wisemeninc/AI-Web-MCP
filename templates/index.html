<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Chat Interface</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #0f0f0f;
            color: #e0e0e0;
            height: 100vh;
            display: grid;
            grid-template-columns: 1fr 350px;
            grid-template-rows: auto 1fr auto;
            grid-template-areas: 
                "header header"
                "chat sidebar"
                "input sidebar";
        }

        .header {
            grid-area: header;
            background: #1a1a1a;
            border-bottom: 1px solid #333;
            padding: 12px 20px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 15px;
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 15px;
            flex: 1;
        }

        .model-selector {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        select {
            background: #2a2a2a;
            color: #e0e0e0;
            border: 1px solid #444;
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 13px;
            cursor: pointer;
            outline: none;
        }

        select:hover {
            border-color: #666;
        }

        .mcp-status {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 12px;
            padding: 4px 10px;
            background: #2a2a2a;
            border-radius: 4px;
            cursor: pointer;
            user-select: none;
        }

        .mcp-status:hover {
            background: #333;
        }

        .mcp-details {
            position: absolute;
            top: 100%;
            right: 0;
            margin-top: 4px;
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 4px;
            padding: 8px;
            font-size: 11px;
            min-width: 200px;
            display: none;
            z-index: 1000;
        }

        .mcp-details.show {
            display: block;
        }

        .mcp-status-wrapper {
            position: relative;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #666;
        }

        .status-dot.connected {
            background: #4ade80;
            box-shadow: 0 0 8px #4ade8080;
        }

        .status-dot.disconnected {
            background: #ef4444;
        }

        .chat-container {
            grid-area: chat;
            overflow-y: auto;
            padding: 12px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .message {
            max-width: 80%;
            padding: 8px 12px;
            border-radius: 8px;
            line-height: 1.4;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .message.user {
            background: #2563eb;
            color: white;
            align-self: flex-end;
            margin-left: auto;
        }

        .message.assistant {
            background: #2a2a2a;
            color: #e0e0e0;
            align-self: flex-start;
            border: 1px solid #333;
        }

        .message.system {
            background: #7c3aed;
            color: white;
            align-self: center;
            font-size: 12px;
            max-width: 60%;
            padding: 6px 10px;
        }

        .message.tool-call {
            background: #f59e0b;
            color: #1a1a1a;
            align-self: center;
            font-size: 11px;
            max-width: 70%;
            font-family: 'Courier New', monospace;
            cursor: pointer;
            transition: opacity 0.2s;
            padding: 6px 10px;
        }

        .message.tool-call:hover {
            opacity: 0.8;
        }

        .message.tool-result {
            background: #10b981;
            color: #1a1a1a;
            align-self: center;
            font-size: 11px;
            max-width: 70%;
            font-family: 'Courier New', monospace;
            cursor: pointer;
            transition: opacity 0.2s;
            padding: 6px 10px;
        }

        .message.tool-result:hover {
            opacity: 0.8;
        }

        .tool-summary {
            font-weight: bold;
            margin-bottom: 2px;
        }

        .tool-details {
            margin-top: 2px;
            padding-top: 2px;
            border-top: 1px solid rgba(0,0,0,0.2);
            font-size: 10px;
        }

        .thinking-section {
            background: #2a2a4a;
            border: 1px solid #3a3a5a;
            border-radius: 4px;
            margin: 8px 0;
            padding: 8px;
            cursor: pointer;
            transition: opacity 0.2s;
        }

        .thinking-section:hover {
            opacity: 0.8;
        }

        .thinking-header {
            font-weight: bold;
            color: #a0a0ff;
            font-size: 11px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .thinking-content {
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid #3a3a5a;
            font-size: 12px;
            white-space: pre-wrap;
            font-family: 'Courier New', monospace;
        }

        .thinking-content.collapsed {
            display: none;
        }

        .toggle-icon {
            font-size: 10px;
        }

        .tool-details.collapsed {
            display: none;
        }

        .input-container {
            grid-area: input;
            background: #1a1a1a;
            border-top: 1px solid #333;
            padding: 15px 20px;
            display: flex;
            gap: 10px;
        }

        .sidebar {
            grid-area: sidebar;
            background: #1a1a1a;
            border-left: 1px solid #333;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .sidebar-section {
            display: flex;
            flex-direction: column;
            border-bottom: 1px solid #333;
            overflow: hidden;
        }

        .sidebar-section:last-child {
            border-bottom: none;
            flex: 1;
        }

        .sidebar-header {
            padding: 10px 15px;
            background: #222;
            border-bottom: 1px solid #333;
            font-size: 12px;
            font-weight: 600;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .sidebar-content {
            padding: 12px;
            overflow-y: auto;
            flex: 1;
        }

        .prompt-display {
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 4px;
            padding: 10px;
            font-size: 12px;
            line-height: 1.5;
            color: #bbb;
            white-space: pre-wrap;
            word-wrap: break-word;
            max-height: 200px;
            overflow-y: auto;
        }

        .prompt-editor {
            background: #2a2a2a;
            border: 1px solid #444;
            color: #e0e0e0;
            padding: 10px;
            border-radius: 4px;
            font-size: 12px;
            outline: none;
            resize: none;
            font-family: inherit;
            line-height: 1.5;
            width: 100%;
            min-height: 150px;
        }

        .prompt-editor:focus {
            border-color: #2563eb;
        }

        .prompt-actions {
            display: flex;
            gap: 8px;
            margin-top: 8px;
        }

        .prompt-button {
            background: #2563eb;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 11px;
            cursor: pointer;
            transition: background 0.2s;
            flex: 1;
        }

        .prompt-button:hover {
            background: #1d4ed8;
        }

        .prompt-button.secondary {
            background: #444;
        }

        .prompt-button.secondary:hover {
            background: #555;
        }

        .toggle-sidebar {
            display: none;
            background: #2563eb;
            color: white;
            border: none;
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 11px;
            cursor: pointer;
            margin-left: auto;
        }

        @media (max-width: 1024px) {
            body {
                grid-template-columns: 1fr;
                grid-template-areas: 
                    "header"
                    "chat"
                    "input";
            }

            .sidebar {
                display: none;
                position: fixed;
                right: 0;
                top: 0;
                bottom: 0;
                width: 350px;
                z-index: 1000;
                box-shadow: -2px 0 10px rgba(0,0,0,0.5);
            }

            .sidebar.show {
                display: flex;
            }

            .toggle-sidebar {
                display: block;
            }
        }

        #message-input {
            flex: 1;
            background: #2a2a2a;
            border: 1px solid #444;
            color: #e0e0e0;
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 14px;
            outline: none;
            resize: none;
            font-family: inherit;
            max-height: 150px;
        }

        #message-input:focus {
            border-color: #2563eb;
        }

        #send-button {
            background: #2563eb;
            color: white;
            border: none;
            padding: 10px 24px;
            border-radius: 8px;
            font-size: 14px;
            cursor: pointer;
            transition: background 0.2s;
            white-space: nowrap;
        }

        #send-button:hover:not(:disabled) {
            background: #1d4ed8;
        }

        #send-button:disabled {
            background: #444;
            cursor: not-allowed;
            opacity: 0.6;
        }

        .typing-indicator {
            display: none;
            align-self: flex-start;
            background: #2a2a2a;
            padding: 12px 16px;
            border-radius: 12px;
            border: 1px solid #333;
        }

        .typing-indicator.active {
            display: block;
        }

        .typing-dots {
            display: flex;
            gap: 4px;
        }

        .typing-dots span {
            width: 8px;
            height: 8px;
            background: #666;
            border-radius: 50%;
            animation: typing 1.4s infinite;
        }

        .typing-dots span:nth-child(2) {
            animation-delay: 0.2s;
        }

        .typing-dots span:nth-child(3) {
            animation-delay: 0.4s;
        }

        @keyframes typing {
            0%, 60%, 100% {
                transform: translateY(0);
                opacity: 0.7;
            }
            30% {
                transform: translateY(-10px);
                opacity: 1;
            }
        }

        .empty-state {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #666;
            font-size: 14px;
            text-align: center;
        }

        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: #1a1a1a;
        }

        ::-webkit-scrollbar-thumb {
            background: #444;
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #555;
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="header-left">
            <div class="model-selector">
                <select id="provider-select">
                    <option value="">Select Provider</option>
                </select>
                <select id="model-select" disabled>
                    <option value="">Select Model</option>
                </select>
            </div>
        </div>
        <button class="toggle-sidebar" id="toggle-sidebar">Prompts â˜°</button>
        <div class="mcp-status-wrapper">
            <div class="mcp-status" id="mcp-status-container">
                <span class="status-dot" id="mcp-dot"></span>
                <span id="mcp-text">MCP: Checking...</span>
            </div>
            <div class="mcp-details" id="mcp-details"></div>
        </div>
    </div>

    <div class="chat-container" id="chat-container">
        <div class="empty-state">
            Select a provider and model to start chatting
        </div>
    </div>

    <div class="typing-indicator" id="typing-indicator">
        <div class="typing-dots">
            <span></span>
            <span></span>
            <span></span>
        </div>
    </div>

    <div class="input-container">
        <textarea id="message-input" placeholder="Type your message..." rows="1"></textarea>
        <button id="send-button" disabled>Send</button>
    </div>

    <div class="sidebar" id="sidebar">
        <div class="sidebar-section">
            <div class="sidebar-header">
                <span>System Prompt</span>
            </div>
            <div class="sidebar-content">
                <div class="prompt-display" id="system-prompt-display">Loading...</div>
            </div>
        </div>
        
        <div class="sidebar-section">
            <div class="sidebar-header">
                <span>User Prompt</span>
            </div>
            <div class="sidebar-content">
                <textarea class="prompt-editor" id="user-prompt-editor" placeholder="Enter custom instructions for the AI..."></textarea>
                <div class="prompt-actions">
                    <button class="prompt-button" id="apply-user-prompt">Apply</button>
                    <button class="prompt-button secondary" id="clear-user-prompt">Clear</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        let providers = {};
        let currentProvider = '';
        let currentModel = '';
        let messages = [];
        let isStreaming = false;
        let messageHistory = [];
        let historyIndex = -1;
        let systemPrompt = 'You are a helpful AI assistant.';
        let userPrompt = '';

        // Elements
        const providerSelect = document.getElementById('provider-select');
        const modelSelect = document.getElementById('model-select');
        const chatContainer = document.getElementById('chat-container');
        const messageInput = document.getElementById('message-input');
        const sendButton = document.getElementById('send-button');
        const typingIndicator = document.getElementById('typing-indicator');
        const mcpDot = document.getElementById('mcp-dot');
        const mcpText = document.getElementById('mcp-text');
        const systemPromptDisplay = document.getElementById('system-prompt-display');
        const userPromptEditor = document.getElementById('user-prompt-editor');
        const applyUserPromptBtn = document.getElementById('apply-user-prompt');
        const clearUserPromptBtn = document.getElementById('clear-user-prompt');
        const toggleSidebarBtn = document.getElementById('toggle-sidebar');
        const sidebar = document.getElementById('sidebar');

        // Load providers
        async function loadProviders() {
            try {
                const response = await fetch('/api/providers');
                providers = await response.json();
                
                providerSelect.innerHTML = '<option value="">Select Provider</option>';
                Object.keys(providers).forEach(key => {
                    const option = document.createElement('option');
                    option.value = key;
                    option.textContent = providers[key].name;
                    providerSelect.appendChild(option);
                });
                return providers;
            } catch (error) {
                console.error('Failed to load providers:', error);
                return {};
            }
        }

        // Check MCP status
        async function checkMCPStatus() {
            try {
                const response = await fetch('/api/mcp/status');
                const data = await response.json();
                
                if (data.connected) {
                    mcpDot.classList.add('connected');
                    mcpDot.classList.remove('disconnected');
                    mcpText.textContent = 'MCP: ' + data.message;
                    
                    // Update details panel
                    const detailsHtml = data.servers.map(s => 
                        `<div style="padding: 4px 0;">${s.connected ? 'âœ“' : 'âœ—'} ${s.name}: ${s.message}</div>`
                    ).join('');
                    mcpDetails.innerHTML = detailsHtml;
                } else {
                    mcpDot.classList.remove('connected');
                    mcpDot.classList.add('disconnected');
                    mcpText.textContent = 'MCP: ' + data.message;
                    mcpDetails.innerHTML = '<div style="padding: 4px 0;">No servers connected</div>';
                }
            } catch (error) {
                mcpDot.classList.remove('connected');
                mcpDot.classList.add('disconnected');
                mcpText.textContent = 'MCP: Error';
                mcpDetails.innerHTML = '<div style="padding: 4px 0;">Connection error</div>';
            }
        }

        // Toggle MCP details
        const mcpStatusContainer = document.getElementById('mcp-status-container');
        const mcpDetails = document.getElementById('mcp-details');
        
        mcpStatusContainer.addEventListener('click', () => {
            mcpDetails.classList.toggle('show');
        });

        // Close details when clicking outside
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.mcp-status-wrapper')) {
                mcpDetails.classList.remove('show');
            }
        });

        // Provider change handler
        providerSelect.addEventListener('change', (e) => {
            currentProvider = e.target.value;
            modelSelect.innerHTML = '<option value="">Select Model</option>';
            
            if (currentProvider && providers[currentProvider]) {
                const models = providers[currentProvider].models;
                models.forEach(model => {
                    const option = document.createElement('option');
                    option.value = model;
                    option.textContent = model;
                    modelSelect.appendChild(option);
                });
                modelSelect.disabled = false;
            } else {
                modelSelect.disabled = true;
                currentModel = '';
                sendButton.disabled = true;
            }
        });

        // Model change handler
        modelSelect.addEventListener('change', (e) => {
            currentModel = e.target.value;
            sendButton.disabled = !currentModel;
        });

        // Render message with collapsible thinking sections
        function renderMessageWithThinking(messageDiv, content) {
            // Parse thinking/scratchpad tags
            const thinkingRegex = /<(scratchpad|thinking)>([\s\S]*?)<\/(scratchpad|thinking)>/gi;
            const answerRegex = /<answer>([\s\S]*?)<\/answer>/gi;
            
            let html = '';
            let lastIndex = 0;
            let match;
            
            // Find all thinking/scratchpad sections
            const matches = [];
            const regex = /<(scratchpad|thinking|answer)>([\s\S]*?)<\/(scratchpad|thinking|answer)>|([^<]+|<(?!\/?(scratchpad|thinking|answer)>))/gi;
            
            let processedContent = content;
            
            // Replace thinking/scratchpad tags with collapsible divs
            processedContent = processedContent.replace(/<(scratchpad|thinking)>([\s\S]*?)<\/(scratchpad|thinking)>/gi, 
                (match, tag, content) => {
                    const id = 'thinking-' + Math.random().toString(36).substr(2, 9);
                    return `<div class="thinking-section" onclick="document.getElementById('${id}').classList.toggle('collapsed')">
                        <div class="thinking-header"><span class="toggle-icon">â–¼</span> ${tag.charAt(0).toUpperCase() + tag.slice(1)}</div>
                        <div class="thinking-content collapsed" id="${id}">${escapeHtml(content.trim())}</div>
                    </div>`;
                }
            );
            
            // Remove answer tags but keep content
            processedContent = processedContent.replace(/<\/?answer>/gi, '');
            
            messageDiv.innerHTML = processedContent;
        }
        
        // Escape HTML to prevent XSS
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Add message to chat
        function addMessage(role, content) {
            const emptyState = chatContainer.querySelector('.empty-state');
            if (emptyState) {
                emptyState.remove();
            }

            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${role}`;
            messageDiv.textContent = content;
            chatContainer.appendChild(messageDiv);
            
            // Smooth scroll to bottom
            chatContainer.scrollTo({
                top: chatContainer.scrollHeight,
                behavior: 'smooth'
            });
            
            return messageDiv;
        }

        // Load system prompt from backend
        async function loadSystemPrompt() {
            try {
                const response = await fetch('/api/system-prompt');
                const data = await response.json();
                systemPrompt = data.system_prompt || 'You are a helpful AI assistant.';
                // Replace \n with actual newlines for display
                systemPromptDisplay.textContent = systemPrompt.replace(/\\n/g, '\n');
            } catch (error) {
                console.error('Failed to load system prompt:', error);
                systemPromptDisplay.textContent = 'Error loading system prompt';
            }
        }

        // Apply user prompt
        applyUserPromptBtn.addEventListener('click', () => {
            userPrompt = userPromptEditor.value.trim();
            if (userPrompt) {
                addMessage('system', 'âœ“ User prompt applied: ' + userPrompt.substring(0, 100) + (userPrompt.length > 100 ? '...' : ''));
            }
        });

        // Clear user prompt
        clearUserPromptBtn.addEventListener('click', () => {
            userPrompt = '';
            userPromptEditor.value = '';
            addMessage('system', 'âœ“ User prompt cleared');
        });

        // Toggle sidebar on mobile
        toggleSidebarBtn.addEventListener('click', () => {
            sidebar.classList.toggle('show');
        });

        // Close sidebar when clicking outside on mobile
        document.addEventListener('click', (e) => {
            if (window.innerWidth <= 1024 && 
                !e.target.closest('.sidebar') && 
                !e.target.closest('.toggle-sidebar')) {
                sidebar.classList.remove('show');
            }
        });

        // Send message
        async function sendMessage() {
            const content = messageInput.value.trim();
            if (!content || !currentProvider || !currentModel || isStreaming) return;

            isStreaming = true;
            sendButton.disabled = true;
            
            // Add to history
            messageHistory.push(content);
            historyIndex = messageHistory.length;
            
            messageInput.value = '';
            
            // Combine user prompt with message if set
            let finalContent = content;
            if (userPrompt) {
                finalContent = `${userPrompt}\n\n${content}`;
            }
            
            // Add user message (display original, send combined)
            messages.push({ role: 'user', content: finalContent });
            addMessage('user', content);
            
            // Show typing indicator
            typingIndicator.classList.add('active');
            chatContainer.appendChild(typingIndicator);
            
            try {
                const response = await fetch('/api/chat', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        messages: messages,
                        provider: currentProvider,
                        model: currentModel
                    })
                });

                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let assistantMessage = '';
                let messageDiv = null;
                let streamDone = false;

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) {
                        console.log('Stream ended. Final message length:', assistantMessage.length);
                        break;
                    }

                    const chunk = decoder.decode(value, { stream: true });
                    const lines = chunk.split('\n');

                    for (const line of lines) {
                        if (line.startsWith('data: ')) {
                            try {
                                const data = JSON.parse(line.slice(6));
                                
                                if (data.content) {
                                    if (!messageDiv) {
                                        typingIndicator.classList.remove('active');
                                        messageDiv = addMessage('assistant', '');
                                    }
                                    assistantMessage += data.content;
                                    
                                    // Process and render message with collapsible thinking sections
                                    renderMessageWithThinking(messageDiv, assistantMessage);
                                    
                                    // Keep scrolling to bottom during streaming
                                    chatContainer.scrollTop = chatContainer.scrollHeight;
                                }
                                
                                if (data.tool_call) {
                                    typingIndicator.classList.remove('active');
                                    const argsStr = JSON.stringify(data.arguments, null, 2);
                                    const toolMsg = document.createElement('div');
                                    toolMsg.className = 'message tool-call';
                                    toolMsg.innerHTML = `<div class="tool-summary">ðŸ”§ ${data.tool_call}</div><div class="tool-details collapsed">${argsStr}</div>`;
                                    toolMsg.onclick = function() {
                                        this.querySelector('.tool-details').classList.toggle('collapsed');
                                    };
                                    chatContainer.appendChild(toolMsg);
                                    chatContainer.scrollTop = chatContainer.scrollHeight;
                                }
                                
                                if (data.tool_result) {
                                    const resultStr = JSON.stringify(data.result, null, 2);
                                    const resultMsg = document.createElement('div');
                                    resultMsg.className = 'message tool-result';
                                    resultMsg.innerHTML = `<div class="tool-summary">âœ“ ${data.tool_result}</div><div class="tool-details collapsed">${resultStr}</div>`;
                                    resultMsg.onclick = function() {
                                        this.querySelector('.tool-details').classList.toggle('collapsed');
                                    };
                                    chatContainer.appendChild(resultMsg);
                                    chatContainer.scrollTop = chatContainer.scrollHeight;
                                }
                                
                                if (data.done) {
                                    streamDone = true;
                                }
                                
                                if (data.error) {
                                    typingIndicator.classList.remove('active');
                                    addMessage('system', 'Error: ' + data.error);
                                }
                            } catch (e) {
                                console.error('Parse error:', e, 'Line:', line);
                            }
                        }
                    }
                }
                
                // Always save the assistant message after stream ends
                if (assistantMessage) {
                    messages.push({ role: 'assistant', content: assistantMessage });
                    console.log('Saved assistant message. Total length:', assistantMessage.length);
                }
            } catch (error) {
                console.error('Error:', error);
                typingIndicator.classList.remove('active');
                addMessage('system', 'Error: ' + error.message);
            } finally {
                isStreaming = false;
                sendButton.disabled = !currentModel;
                typingIndicator.classList.remove('active');
            }
        }

        // Send button click
        sendButton.addEventListener('click', sendMessage);

        // Enter key to send (Shift+Enter for new line), arrow keys for history
        messageInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendMessage();
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                if (messageHistory.length > 0 && historyIndex > 0) {
                    historyIndex--;
                    messageInput.value = messageHistory[historyIndex];
                    // Move cursor to end
                    messageInput.setSelectionRange(messageInput.value.length, messageInput.value.length);
                    // Trigger resize
                    messageInput.dispatchEvent(new Event('input'));
                }
            } else if (e.key === 'ArrowDown') {
                e.preventDefault();
                if (historyIndex < messageHistory.length - 1) {
                    historyIndex++;
                    messageInput.value = messageHistory[historyIndex];
                    // Move cursor to end
                    messageInput.setSelectionRange(messageInput.value.length, messageInput.value.length);
                    // Trigger resize
                    messageInput.dispatchEvent(new Event('input'));
                } else if (historyIndex === messageHistory.length - 1) {
                    historyIndex = messageHistory.length;
                    messageInput.value = '';
                    messageInput.dispatchEvent(new Event('input'));
                }
            }
        });

        // Auto-resize textarea
        messageInput.addEventListener('input', () => {
            messageInput.style.height = 'auto';
            messageInput.style.height = messageInput.scrollHeight + 'px';
        });

        // Initialize
        loadProviders().then(() => {
            // Set default provider and model
            const defaultProvider = 'ollama';
            const defaultModel = 'gpt-oss:latest';
            
            if (providers[defaultProvider]) {
                providerSelect.value = defaultProvider;
                currentProvider = defaultProvider;
                
                // Populate models
                modelSelect.innerHTML = '<option value="">Select Model</option>';
                const models = providers[defaultProvider].models;
                models.forEach(model => {
                    const option = document.createElement('option');
                    option.value = model;
                    option.textContent = model;
                    if (model === defaultModel) {
                        option.selected = true;
                    }
                    modelSelect.appendChild(option);
                });
                
                modelSelect.disabled = false;
                
                // Set default model
                if (models.includes(defaultModel)) {
                    currentModel = defaultModel;
                    modelSelect.value = defaultModel;
                    sendButton.disabled = false;
                }
            }
            
            // Focus the input field after initialization
            messageInput.focus();
        });
        
        // Load system prompt
        loadSystemPrompt();
        
        // Check MCP status
        checkMCPStatus();
        setInterval(checkMCPStatus, 10000); // Check MCP status every 10 seconds
    </script>
</body>
</html>
